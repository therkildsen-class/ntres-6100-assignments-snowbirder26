---
title: "Lab 8"
author: "Hannah Pryor"
format: gfm
---

<br>

Load packages

```{r, output=FALSE}
library(tidyverse)
library(ggplot2)
library(dplyr)
library(knitr)
```

<br>

There are two general approaches when generating outputs from for loops. The first approach is to define the output as a NULL object before the loop, and in each iteration, append an element to the output using functions such as `c()` and `bind_rows()`. The second approach is to pre-specify the type and length of the output before the loop, and fill in the output in each iteration. Design an experiment to systematically compare the computational efficiency between the two approaches:

<br>

Approach one:

```{r}
x <- 1:10
y <- 11:20
z <- NULL
for (i in 1:length(x)){
  z <- c(z, x[i] + y[i])
}
z
```

<br>

Approach two:

```{r}
x <- 1:10
y <- 11:20
z <- vector(mode = "double", length=10)
for (i in 1:length(x)){
  z[i] <- x[i] + y[i]
}
z
```

<br>

How can we compare this?

**Given:** the `system.time()` function may be helpful

How does the `system.time()` function work?

```{r, output=FALSE}
?system.time()
```

Okay, looks like you can just copy-paste the code in here:

```{r}
# for approach one:
system.time(for (i in 1:length(x)){
  z <- c(z, x[i] + y[i])
})

# for approach two:
system.time(for (i in 1:length(x)){
  z[i] <- x[i] + y[i]
})
```

Okay, I am seeing a more efficient user time for approach one, but lets add bigger numbers to test if this holds up...

Wait, no, now it is giving me different answers every time! I think I'll still try the bigger numbers and see how that goes.

<br>

```{r}
# ended up using the "possible solution" code to help me do this...

n_iterations <- (1:5)*5000
approach_1 <- vector("double", length(n_iterations))
approach_2 <- vector("double", length(n_iterations))

# for approach one:
for(i in length(n_iterations)){ 
  n <- n_iterations[i]
  z <- NULL
  approach_1[i] <- system.time(for (j in 1:n){
  z <- c(z, 1)
  })[3]
}

# for approach two:
for(i in length(n_iterations)){ 
  n <- n_iterations[i]
  z <- vector(mode = "double", length=n)
  approach_2[i] <- system.time(for (j in 1:n){
  z <- c(z, 1)
  })[3]
}

# graphing these
tibble(n_iterations, approach_1, approach_2) |>
  pivot_longer(2:3, names_to = "approach", values_to = "runtime") |>
  ggplot(aes(x=n_iterations, y=runtime, color=approach)) +
  geom_line()
```

Approach one is more effective, but you do not see this difference until \~20000 iterations

<br>
